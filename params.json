{
  "name": "Try-catch",
  "tagline": "总结js中的try catch",
  "body": "# 总结js中的try catch\r\n\r\ntry...catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。\r\n\r\n语法：\r\n\r\n```\r\ntry\r\n{\r\n\t//要运行的代码\r\n}\r\ncatch(err)\r\n{\r\n\t//出现错误时要允许的代码\r\n}\r\n```\r\n\r\n**大多数情况下，try catch适用于三种场合：**\r\n\r\n1、浏览器原罪的场合：也就是兼容性场合，由于不同浏览器的报错提示是不一样的，根据捕获的浏览器的报错提示判断用户的浏览器，然后做出对应的措施。\r\n\r\n2、中间有繁琐的判断的。比如说筛选面板。初始化的时候有太多的下拉框选项需要从后台加载，可能我没必要每一个下拉框都进行错误处理，因为我只关注所有的查询选项都加载成功，我才能发起查询的请求。只要有一个下拉框选项没加载成功，我就把错误抛给用户，不再发起查询的请求。再比如window.a.b.c.d 我要判断d等于不等于5。那如果window.a根本不存在，我根本没法判断d。所以，我要用n个if判断a b c 分别存在。再判断d。这还不如直接一个try catch呢。只要中间出错。我就直接执行catch。\r\n\r\n使用try catch\r\n\r\n```\r\ntry\r\n{\r\n\twindow.a.b.c.d !== 5;\r\n}\r\ncatch(err)\r\n{\r\n\tconsole.log(\"hello world!\")\r\n}\r\n\r\n```\r\n\r\n不使用try catch\r\n\r\n```\r\nif(window.a){\r\n\tif(window.a.b){\r\n\t\tif(window.a.b.c){\r\n\t\t\tif(window.a.b.c.d!==5){\r\n\t\t\t\tconsole.log(\"hellow world!\")\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n有没有崩溃的感觉。即使用&&来简化一下，也需要写成这样的\r\n\r\n```\r\nif(window.a && window.a.b && window.a.b.c && window.a.b.c.d !==5){\r\n\tconsole.log(\"hello world!\");\r\n}\r\n\r\n```\r\n\r\n3、用在nodejs中异常的处理。比如写爬虫。如果半夜三更，你的爬虫遇到了复杂网页的未知错误。如果没用try catch。你的线程就崩溃。程序就停止了。但是如果有了try catch。遇到错误就放弃处理这个网页。转向爬去其他页面。\r\n\r\n**try catch 中的坑**\r\n\r\ntry catch只能捕获当次事件循环内的异常，对call back执行时抛出的异常将无能为力\r\n\r\n```\r\nfunction jsonp(setting){\r\n  setting.data = setting.data || {}\r\n  setting.key = setting.key||'callback'\r\n  setting.callback = setting.callback||function(){} \r\n  setting.data[setting.key] = '__onGetData__'\r\n\r\n  window.__onGetData__ = function(data){\r\n    setting.callback (data);\r\n  }\r\n\r\n  var script = document.createElement('script')\r\n  var query = []\r\n  for(var key in setting.data){\r\n    query.push( key + '='+ encodeURIComponent(setting.data[key]) )\r\n  }\r\n  script.src = setting.url + '?' + query.join('&')\r\n  document.head.appendChild(script)\r\n  document.head.removeChild(script)\r\n\r\n}\r\n\r\ntry\r\n{\r\n  jsonp({\r\n  url: 'http://photo.sina.cn/aj/index',\r\n  key: 'jsoncallback',\r\n  data: {\r\n    page: 1,\r\n    cate: 'recommend'\r\n  },\r\n  callback: function(ret){\r\n    console.hhhhhhh(ret);   // 这是一句错误的语句。但是并没有被catch到。\r\n  }\r\n  })\r\n  console.log(\"jsonp已经执行\");\r\n}catch(err)\r\n{\r\n  console.log(err);\r\n}\r\n\r\n```\r\n\r\n上边这个例子中，首先定义了一个函数jsonp。这个函数有回调函数。在我运行jsonp的时候.我向jsonp中传送的回调函数有故意写错的地方。但是在控制台里并没有把这个错误打印出来。说明回调函数运行时的错误try catch无法捕捉到。[演示地址](http://codepen.io/zhaojianxin/pen/xEzBwk?editors=0011)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}